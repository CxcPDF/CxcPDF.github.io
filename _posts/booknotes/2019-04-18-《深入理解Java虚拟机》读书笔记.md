---
layout: post
title: 《深入理解Java虚拟机》读书笔记
categories: [读书笔记]
description: 深入理解Java虚拟机
keywords: JVM
---

# 第2章 Java内存区域与内存溢出异常
* Java虚拟机运行时数据区：程序计数器（PC）、Java虚拟机栈、本地方法栈、堆区、方法区。
* ![d7e8d2d058de2dc665f41e7b6fa381a6.png](en-resource://database/12183:1)


* 程序计数器：是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储。是“线程私有”的内存。执行Java方法的时候，PC记录的是正在执行的虚拟机字节码指令的地址，执行的是Native方式，PC为空。这是唯一一个没有规定任何OOM的区域。
* Java虚拟机栈：线程私有，生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧用于存储**局部变量表、操作栈、动态链接、方法出口**等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机中从入栈到出栈的过程。虚拟机栈中的**局部变量表**存放了各种基本数据类型、对象引用和returnAddress类型。局部变量表所需要的内存空间在**编译期间**完成分配。
   1. StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度
   2. OutOfMemoryError：虚拟机栈在动态扩展是无法申请到足够的内存。

* 本地方法栈：虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。（Hotspot虚拟机直接把本地方法栈和虚拟机栈合二为一）
* Java堆：Java虚拟机所管理的内存中最大的一块。被所有线程共享，在虚拟机启动时创建。存放对象实例。Java堆是垃圾收集器管理的主要区域。分为：新生代和老年代，细分可以为：Eden空间、From Survivor空间、To Survivor空间。Java堆可以处于物理上不连续的内存空间中，只要逻辑连续即可。
* 方法区：线程共享，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码。垃圾收集行为在这个区域比较少，主要是针对常量池的回收和对类型的卸载。
* 运行时常量池：是方法区的一部分，用于存放编译器生成的各种字面量和符号引用
* ![07149e48ac31810ec7df34a643a357f7.png](en-resource://database/12187:1)
* 直接内存：直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。NIO引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。


* Java对象访问方式有两种：使用句柄和直接指针
   1. 使用句柄：Java堆中划分出一块内存作为句柄池，reference中存的是对象的句柄地址，句柄中包含了对象实例数据和类型数据各自的具体地址信息
   ![a8459958fa419ecb6502b94d827fcce8.png](en-resource://database/12189:1)
   
   2. 直接指针：要考虑如何防止访问类型数据的相关信息，reference中直接存储的是对象地址。
   ![d51b53b888624bec24870b56f792f412.png](en-resource://database/12191:1)
   
   3. 两种方式比较：
   * 句柄方式：reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改。
   * 直接指针：速度快，节省了一次指针定位的时间开销。


# 第3章 垃圾收集器和内存分配策略
* 判断对象是否已死：
  1. 引用计数法：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器都为0的对象就是不可能在被使用的。但是它很难解决对象之间的相互循环引用的问题。
  2. 根搜索算法（可达性分析）：![82a3ebc0c4cae44fb947c72c263c0e54.png](en-resource://database/12193:1)
  ![a3f4828bfeb646ede90ac151a1b62f8c.png](en-resource://database/12195:1)
 
 
 ###### 内存分配与回收策略
 * 对象的内存分配，往大方向上讲就是在堆上分配，对象主要分配在新生代的Eden区上，如果启动；了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能直接分配在老年代中。
 * 大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。
  
# 第4章 虚拟机性能监控与故障处理工具
# 第5章 调优案例分析与实战





#### 为对象分配空间的方式：
1. 指针碰撞：假设Java堆内存是绝对规整的，所有用过的内存放在一边，空闲的内存放在一边，中间放着一个指针作为分界点的指示器，分配内存时把指针向空闲空间那边挪动一段与对象大小相等的距离。
2. 空闲列表：如果内存不是规整的，则会维护一个列表记录哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。


# 第7章 虚拟机类加载机制
* 虚拟机类加载机制：虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型
* 类的生命周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段。期中验证、准备、解析3个部分称为连接。

![b21e1c31ca77a09f8fd08eb7d74846ff.png](en-resource://database/11698:1)

* Java虚拟机规范并没有强制规定什么情况下开始类加载过程的第一个阶段，但是对于初始化阶段，虚拟机规范则严格规定了5中情况立即对类进行初始化：
   1. ![7b618e9ceed3e4844b6a8dd9681809f2.png](en-resource://database/11700:1)
   2. ![e65eb8857a2e302f855eab595dea1131.png](en-resource://database/11702:1)
   3. ![bf1303d1b0adb4372a09138d26b81671.png](en-resource://database/11704:1)
   4. ![8fdb29b4d0a5499dca08778f99f7a8a2.png](en-resource://database/11706:1)
   5. ![7de369332afe32f01dd1d65bf7d1c181.png](en-resource://database/11708:1)

* **类加载的过程**
    1. 加载：![60d22b1703c567d20cd5226e4535d9fb.png](en-resource://database/11710:1)
    2. 验证：目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。会完成4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。
    3. 准备：正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存将在方法区中进行分配。但是这个时候内存分配的进包括类变量（被static修饰的变量），而不包括实例变量，实例变量将在对象实例化时随对象一起分配在Java堆中。
    4. 解析：虚拟机将常量池内的符号应用替换为直接引用的过程。![6da8d39e6c45c20bb04d9bb7e46b18db.png](en-resource://database/11712:1)
    包括类或接口的解析、字段解析、类方法解析、接口方法解析
    5. 初始化：根据程序员通过程序制定的主观计划去初始化类变量和其他资源（也就是执行类构造器<clinit>()方法的过程）
    
    
### 类加载器
* 比较两个类是否相等，只有在这个两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类必定不相等。


###### 双亲委派模型
* 两种类加载器：
     1. 启动类加载器（Bootstrap ClassLoader），用C++语言实现，是虚拟机自身的一部分
     2. 所有的其他类加载器，由Java实现，独立于虚拟机外部，继承自java.lang.ClassLoader
 
 * 系统提供的三种类加载器：
      1. 启动类加载器（BootStrap ClassLoader）
      2. 扩展类加载器（Extension ClassLoader）
      3. 应用程序类加载器（Application ClassLoader）
   
   * 双亲委派模型工作过程：![2d1184faf32aadff8f58c101e6af5da5.png](en-resource://database/11714:1)
   
   
# 第12章



---
欢迎关注我的微信公众号，接收最新动态。

<div align="center"><img width="192px" height="192px" src="https://i.postimg.cc/pdykktnS/weichat.jpg"/></div>
